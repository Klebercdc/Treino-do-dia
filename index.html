/* eslint-disable no-var */
/**
 * TITAN PRO — GAS Gateway (Agentic Orchestrator)
 *
 * Endpoints (Web App):
 *   GET  /exec                          -> health
 *   POST /exec/v1/titanpro/analyze      -> planner + verifier + writer (Nemotron via NIM)
 *
 * Script Properties (Project Settings -> Script properties):
 *   NVIDIA_API_KEY         (obrigatório)
 *   NVIDIA_MODEL           (opcional; default: nvidia/llama-3.1-nemotron-70b-instruct)
 *   NVIDIA_ENDPOINT        (opcional; default: https://integrate.api.nvidia.com/v1/chat/completions)
 *   GATEWAY_SECRET         (opcional; se setado, o cliente precisa enviar auth.secret no body)
 *
 * Observação: Apps Script não permite setar status HTTP custom via ContentService.
 * Portanto a API sempre responde 200, mas inclui { ok: true/false }.
 */

const CONST = Object.freeze({
  SERVICE: "titanpro_gateway",
  VERSION: "gas_v1",
  DEFAULT_NIM_ENDPOINT: "https://integrate.api.nvidia.com/v1/chat/completions",
  DEFAULT_NIM_MODEL: "nvidia/llama-3.1-nemotron-70b-instruct",
  MAX_BODY_CHARS: 500_000, // guardrail
});

function doGet() {
  return jsonOut({
    ok: true,
    service: CONST.SERVICE,
    version: CONST.VERSION,
    now: new Date().toISOString(),
  });
}

function doPost(e) {
  const requestId = Utilities.getUuid();
  const startedAt = Date.now();

  try {
    const path = normalizePath((e && e.pathInfo) || "/");
    const bodyText = getBodyText(e);

    if (bodyText && bodyText.length > CONST.MAX_BODY_CHARS) {
      return jsonOut({
        ok: false,
        requestId,
        error: { code: "BODY_TOO_LARGE", message: "Body muito grande." },
      });
    }

    const req = safeJsonParse(bodyText) || {};
    const secretOk = verifyGatewaySecret(req);
    if (!secretOk) {
      return jsonOut({
        ok: false,
        requestId,
        error: { code: "UNAUTHORIZED", message: "Secret inválido." },
      });
    }

    if (path === "/v1/titanpro/analyze") {
      const result = Orchestrator.handleTitanProAnalyze(req, requestId);
      result.meta = Object.assign({}, result.meta || {}, {
        service: CONST.SERVICE,
        version: CONST.VERSION,
        path,
        tookMs: Date.now() - startedAt,
      });
      return jsonOut(result);
    }

    return jsonOut({
      ok: false,
      requestId,
      error: { code: "NOT_FOUND", message: `Rota desconhecida: ${path}` },
      meta: { service: CONST.SERVICE, version: CONST.VERSION, path, tookMs: Date.now() - startedAt },
    });
  } catch (err) {
    return jsonOut({
      ok: false,
      requestId,
      error: { code: "UNHANDLED", message: String(err && err.message ? err.message : err) },
      meta: { service: CONST.SERVICE, version: CONST.VERSION, tookMs: Date.now() - startedAt },
    });
  }
}

// =========================
// Orchestrator (agentic core)
// =========================
const Orchestrator = {
  handleTitanProAnalyze(req, requestId) {
    const session = req && req.session ? req.session : null;
    const history = Array.isArray(req && req.history) ? req.history : [];

    if (!session || session.schema !== "titanpro_session_v3") {
      return {
        ok: false,
        requestId,
        error: { code: "BAD_REQUEST", message: "session.schema inválido (esperado titanpro_session_v3)." },
      };
    }

    const normalized = Normalizer.normalizeWorkout(session, history);
    const flags = RulesEngine.computeFlags(normalized);

    const planner = new NemotronPlanner({
      endpoint: getProp("NVIDIA_ENDPOINT", CONST.DEFAULT_NIM_ENDPOINT),
      model: getProp("NVIDIA_MODEL", CONST.DEFAULT_NIM_MODEL),
      apiKey: getRequiredProp("NVIDIA_API_KEY"),
    });

    // 1) Planner (Nemotron) — se falhar, cai em fallback
    let plan = null;
    let plannerEngine = "nemotron";
    let plannerModel = planner.model;

    try {
      plan = planner.planWorkout({
        requestId,
        session: normalized.sessionSlim, // reduz tokens
        trends: normalized.trends,
        flags,
      });

      // 2) Verifier + hardening
      const verified = Verifier.verifyWorkoutPlan(plan, normalized);
      if (!verified.ok) {
        throw new Error("Plano inválido pelo verifier: " + verified.message);
      }
      plan = verified.plan;
    } catch (err) {
      plannerEngine = "fallback_heuristics";
      plannerModel = "local_rules";
      plan = FallbackPlanner.planWorkout(normalized, flags, String(err && err.message ? err.message : err));
    }

    // 3) Writer (texto final) — aqui em GAS (template) para manter o fluxo completo
    const writerText = Writer.writeWorkout(plan);

    return {
      ok: true,
      requestId,
      planner: {
        engine: plannerEngine,
        model: plannerModel,
        plan,
      },
      writer: {
        engine: "gas_template_writer",
        text: writerText,
      },
      meta: {
        now: new Date().toISOString(),
      },
    };
  },
};

// =========================
// Normalizer
// =========================
const Normalizer = {
  normalizeWorkout(session, history) {
    const sessionSlim = slimSession(session);
    const lastSession = history && history.length ? history[0] : null;
    const prevMap = lastSession ? indexBestE1rmByExercise(lastSession) : {};

    const trends = computeTrends(sessionSlim, prevMap);

    return {
      sessionSlim,
      trends,
    };
  },
};

function slimSession(session) {
  const out = {
    schema: "titanpro_session_slim_v1",
    capturedAt: session.capturedAt || null,
    objetivo: session.objetivo || null,
    frequenciaSemanal: session.frequenciaSemanal || null,
    sections: [],
  };

  const sections = Array.isArray(session.sections) ? session.sections : [];
  for (var i = 0; i < sections.length; i++) {
    const sec = sections[i] || {};
    const treinoKey = String(sec.treinoKey || "Treino");
    const exercises = Array.isArray(sec.exercises) ? sec.exercises : [];

    const exOut = [];
    for (var j = 0; j < exercises.length; j++) {
      const ex = exercises[j] || {};
      const name = String(ex.name || "Exercício");
      const sets = Array.isArray(ex.sets) ? ex.sets : [];

      const validSets = [];
      for (var k = 0; k < sets.length; k++) {
        const s = sets[k] || {};
        const kg = Number(s.kg || 0);
        const reps = Number(s.reps || 0);
        const rpe = clampIntGAS(s.rpe, 1, 10, 10);
        if (!(kg > 0) || !(reps > 0)) continue;
        validSets.push({ kg: kg, reps: reps, rpe: rpe, e1rm: Number(s.e1rm || 0) });
      }

      const metrics = calcMetrics(validSets);
      exOut.push({
        name,
        metrics,
      });
    }

    out.sections.push({
      treinoKey,
      exercises: exOut,
    });
  }

  return out;
}

function calcMetrics(validSets) {
  if (!validSets || !validSets.length) {
    return { bestE1RM: 0, volume: 0, avgRPE: null, avgKg: null };
  }
  var best = 0;
  var vol = 0;
  var sumRpe = 0;
  var sumKg = 0;

  for (var i = 0; i < validSets.length; i++) {
    var s = validSets[i];
    best = Math.max(best, Number(s.e1rm || 0));
    vol += Number(s.kg || 0) * Number(s.reps || 0);
    sumRpe += Number(s.rpe || 0);
    sumKg += Number(s.kg || 0);
  }

  var avgRpe = sumRpe / validSets.length;
  var avgKg = sumKg / validSets.length;

  return {
    bestE1RM: round1(best),
    volume: Math.round(vol),
    avgRPE: round1(avgRpe),
    avgKg: round1(avgKg),
  };
}

function indexBestE1rmByExercise(session) {
  try {
    const s = slimSession(session);
    const map = {};
    for (var i = 0; i < s.sections.length; i++) {
      const sec = s.sections[i];
      for (var j = 0; j < sec.exercises.length; j++) {
        const ex = sec.exercises[j];
        const name = ex.name;
        const best = ex.metrics && ex.metrics.bestE1RM ? ex.metrics.bestE1RM : 0;
        if (!map[name] || best > map[name]) map[name] = best;
      }
    }
    return map;
  } catch (e) {
    return {};
  }
}

function computeTrends(sessionSlim, prevMap) {
  const trendByExercise = {};
  for (var i = 0; i < sessionSlim.sections.length; i++) {
    const sec = sessionSlim.sections[i];
    for (var j = 0; j < sec.exercises.length; j++) {
      const ex = sec.exercises[j];
      const curr = Number(ex.metrics && ex.metrics.bestE1RM ? ex.metrics.bestE1RM : 0);
      const prev = Number(prevMap && prevMap[ex.name] ? prevMap[ex.name] : 0);
      if (prev > 0 && curr > 0) {
        const pct = ((curr - prev) / prev) * 100;
        trendByExercise[ex.name] = round1(pct);
      } else {
        trendByExercise[ex.name] = null;
      }
    }
  }
  return { trendByExercise };
}

// =========================
// RulesEngine (flags tipo KDIGO -> aqui para treino)
// =========================
const RulesEngine = {
  computeFlags(normalized) {
    const flags = {
      highRPE: [],
      lowRPE: [],
      e1rmDrop: [],
      notes: [],
    };

    const s = normalized.sessionSlim;
    const trend = normalized.trends && normalized.trends.trendByExercise ? normalized.trends.trendByExercise : {};

    for (var i = 0; i < s.sections.length; i++) {
      const sec = s.sections[i];
      for (var j = 0; j < sec.exercises.length; j++) {
        const ex = sec.exercises[j];
        const m = ex.metrics || {};
        const avgRPE = Number(m.avgRPE || 0);
        const delta = trend[ex.name];

        if (avgRPE >= 9) flags.highRPE.push(ex.name);
        if (avgRPE > 0 && avgRPE <= 7) flags.lowRPE.push(ex.name);
        if (typeof delta === "number" && delta <= -3) flags.e1rmDrop.push({ name: ex.name, pct: delta });
      }
    }

    if (flags.highRPE.length) flags.notes.push("Há exercícios com RPE médio alto (>=9).");
    if (flags.e1rmDrop.length) flags.notes.push("Há queda relevante de e1RM vs última sessão em alguns exercícios.");

    return flags;
  },
};

// =========================
// Nemotron Planner (NIM via HTTP) — encapsulado
// =========================
class NemotronPlanner {
  constructor(opts) {
    this.endpoint = String(opts && opts.endpoint ? opts.endpoint : CONST.DEFAULT_NIM_ENDPOINT);
    this.model = String(opts && opts.model ? opts.model : CONST.DEFAULT_NIM_MODEL);
    this.apiKey = String(opts && opts.apiKey ? opts.apiKey : "");
    if (!this.apiKey) throw new Error("NVIDIA_API_KEY ausente nas Script Properties.");
  }

  planWorkout(context) {
    const system = [
      "Você é um PLANNER de treino (não é o redator final).",
      "Você recebe métricas agregadas (best e1RM, volume, avgRPE) e tendências vs sessão anterior.",
      "Tarefa: produzir um PLANO estruturado (JSON) com ajustes práticos para a próxima sessão.",
      "",
      "Responda SOMENTE com JSON válido (sem markdown, sem texto fora do JSON).",
      "JSON obrigatório:",
      "{",
      '  "summary": string,',
      '  "perTreino": [',
      "    {",
      '      "treinoKey": string,',
      '      "notes": string,',
      '      "exercises": [',
      "        {",
      '          "name": string,',
      '          "metrics": { "bestE1RM": number, "volume": number, "avgRPE": number|null },',
      '          "trendPctVsLast": number|null,',
      '          "next": {',
      '             "action": "increase"|"maintain"|"decrease",',
      '             "deltaKg": number,',
      '             "repGoal": string,',
      '             "rpeGoal": number',
      "          },",
      '          "why": string',
      "        }",
      "      ]",
      "    }",
      "  ],",
      '  "alerts": [ { "level": "info"|"warning"|"critical", "message": string } ]',
      "}",
      "",
      "Regras de ajuste (resumo):",
      "- Se avgRPE <= 7.5: sugerir increase pequeno (ex.: +2.5kg ou +1-3%).",
      "- Se avgRPE ~ 8-8.5: maintain ou micro-aumento.",
      "- Se avgRPE >= 9: maintain/decrease; priorizar técnica/repGoal.",
      "- Se trendPctVsLast <= -3: alerta de fadiga; sugerir ajuste conservador.",
    ].join("\n");

    const user = JSON.stringify(context);

    const payload = {
      model: this.model,
      temperature: 0.2,
      max_tokens: 900,
      messages: [
        { role: "system", content: system },
        { role: "user", content: user },
      ],
    };

    const resp = nimCall(this.endpoint, this.apiKey, payload);
    const content = extractAssistantContent(resp);
    const plan = parseJsonFromModel(content);
    if (!plan) throw new Error("Planner retornou JSON inválido.");
    return plan;
  }
}

function nimCall(endpoint, apiKey, payloadObj) {
  const res = UrlFetchApp.fetch(endpoint, {
    method: "post",
    contentType: "application/json",
    payload: JSON.stringify(payloadObj),
    headers: {
      Authorization: "Bearer " + apiKey,
    },
    muteHttpExceptions: true,
  });

  const status = res.getResponseCode();
  const text = res.getContentText() || "";
  if (!(status >= 200 && status < 300)) {
    throw new Error("NIM HTTP " + status + ": " + text.slice(0, 1500));
  }
  const data = safeJsonParse(text);
  if (!data) throw new Error("Resposta NIM não-JSON.");
  return data;
}

function extractAssistantContent(nimJson) {
  const choices = nimJson && nimJson.choices ? nimJson.choices : null;
  if (!choices || !choices.length) return "";
  const msg = choices[0] && choices[0].message ? choices[0].message : null;
  return msg && msg.content ? String(msg.content) : "";
}

function parseJsonFromModel(text) {
  if (!text) return null;

  // Tentativa 1: JSON puro
  const direct = safeJsonParse(text);
  if (direct) return direct;

  // Tentativa 2: extrair do primeiro { ao último }
  const first = text.indexOf("{");
  const last = text.lastIndexOf("}");
  if (first >= 0 && last > first) {
    const sliced = text.slice(first, last + 1);
    return safeJsonParse(sliced);
  }

  return null;
}

// =========================
// Verifier (estrutura + hardening)
// =========================
const Verifier = {
  verifyWorkoutPlan(plan, normalized) {
    if (!plan || typeof plan !== "object") return { ok: false, message: "Plano não é objeto.", plan: null };

    if (typeof plan.summary !== "string") return { ok: false, message: "summary ausente.", plan: null };
    if (!Array.isArray(plan.perTreino)) return { ok: false, message: "perTreino não é array.", plan: null };
    if (!Array.isArray(plan.alerts)) plan.alerts = [];

    // Hardening: deltaKg não pode ser absurdo
    // (Clampa com base na avgKg do exercício, quando disponível)
    const sessionSlim = normalized.sessionSlim;
    const avgKgByName = {};
    for (var i = 0; i < sessionSlim.sections.length; i++) {
      const sec = sessionSlim.sections[i];
      for (var j = 0; j < sec.exercises.length; j++) {
        const ex = sec.exercises[j];
        avgKgByName[ex.name] = ex.metrics && ex.metrics.avgKg ? ex.metrics.avgKg : 0;
      }
    }

    for (var a = 0; a < plan.perTreino.length; a++) {
      const t = plan.perTreino[a];
      if (!t || typeof t.treinoKey !== "string") return { ok: false, message: "treinoKey inválido.", plan: null };
      if (!Array.isArray(t.exercises)) return { ok: false, message: "exercises inválido.", plan: null };
      if (typeof t.notes !== "string") t.notes = "";

      for (var b = 0; b < t.exercises.length; b++) {
        const ex = t.exercises[b];
        if (!ex || typeof ex.name !== "string") return { ok: false, message: "exercise.name inválido.", plan: null };
        if (!ex.next || typeof ex.next !== "object") return { ok: false, message: "next ausente.", plan: null };

        const action = String(ex.next.action || "");
        if (["increase", "maintain", "decrease"].indexOf(action) < 0) {
          ex.next.action = "maintain";
        }

        const delta = Number(ex.next.deltaKg || 0);
        const base = Number(avgKgByName[ex.name] || 0);

        // Se não tem base, aceita delta pequeno padrão
        const maxDelta = base > 0 ? Math.max(2.5, round1(base * 0.06)) : 2.5; // ~6%
        const clamped = clampNumberGAS(delta, -maxDelta, maxDelta, 0);

        ex.next.deltaKg = round1(clamped);
        if (typeof ex.next.repGoal !== "string") ex.next.repGoal = "8-12";
        ex.next.rpeGoal = clampIntGAS(ex.next.rpeGoal, 6, 10, 8);

        if (typeof ex.why !== "string") ex.why = "";
        if (!ex.metrics || typeof ex.metrics !== "object") ex.metrics = { bestE1RM: 0, volume: 0, avgRPE: null };
        if (typeof ex.trendPctVsLast !== "number" && ex.trendPctVsLast !== null) ex.trendPctVsLast = null;
      }
    }

    return { ok: true, message: "ok", plan };
  },
};

// =========================
// Fallback Planner (heurístico local)
// =========================
const FallbackPlanner = {
  planWorkout(normalized, flags, reason) {
    const s = normalized.sessionSlim;
    const trend = normalized.trends && normalized.trends.trendByExercise ? normalized.trends.trendByExercise : {};

    const perTreino = [];
    for (var i = 0; i < s.sections.length; i++) {
      const sec = s.sections[i];
      const exs = [];

      for (var j = 0; j < sec.exercises.length; j++) {
        const ex = sec.exercises[j];
        const m = ex.metrics || { bestE1RM: 0, volume: 0, avgRPE: null, avgKg: 0 };

        const avgRPE = Number(m.avgRPE || 0);
        const avgKg = Number(m.avgKg || 0);
        const deltaTrend = trend[ex.name];

        let action = "maintain";
        let deltaKg = 0;
        let repGoal = "8-12";
        let rpeGoal = 8;

        if (avgRPE > 0 && avgRPE <= 7.5) {
          action = "increase";
          deltaKg = avgKg > 0 ? round1(Math.min(2.5, avgKg * 0.03)) : 2.5;
          rpeGoal = 8;
        } else if (avgRPE >= 9) {
          action = "decrease";
          deltaKg = avgKg > 0 ? round1(-Math.min(2.5, avgKg * 0.03)) : -2.5;
          repGoal = "6-10";
          rpeGoal = 8.5;
        } else {
          action = "maintain";
          deltaKg = 0;
          rpeGoal = 8.5;
        }

        if (typeof deltaTrend === "number" && deltaTrend <= -3) {
          // Conservador se caiu e1RM
          action = "maintain";
          deltaKg = 0;
          repGoal = "6-10";
          rpeGoal = 8;
        }

        exs.push({
          name: ex.name,
          metrics: {
            bestE1RM: m.bestE1RM,
            volume: m.volume,
            avgRPE: m.avgRPE,
          },
          trendPctVsLast: typeof deltaTrend === "number" ? deltaTrend : null,
          next: { action, deltaKg: round1(deltaKg), repGoal, rpeGoal },
          why:
            "Plano gerado por regras locais (fallback). " +
            (reason ? "Motivo: " + reason : ""),
        });
      }

      perTreino.push({
        treinoKey: sec.treinoKey,
        notes: "Fallback ativo: ajuste conservador por RPE/tendência.",
        exercises: exs,
      });
    }

    const alerts = [];
    if (flags && flags.highRPE && flags.highRPE.length) {
      alerts.push({ level: "warning", message: "RPE alto em: " + flags.highRPE.join(", ") });
    }
    if (flags && flags.e1rmDrop && flags.e1rmDrop.length) {
      alerts.push({ level: "warning", message: "Queda de e1RM vs última sessão em alguns exercícios." });
    }
    alerts.push({ level: "info", message: "Fallback heurístico usado (Nemotron indisponível ou plano inválido)." });

    return {
      summary:
        "Plano (fallback): ajustes conservadores com base em RPE médio e tendência de e1RM. " +
        "Se o RPE estava baixo, aumenta pouco; se estava alto, mantém/recua.",
      perTreino,
      alerts,
    };
  },
};

// =========================
// Writer (GGUF no outro projeto; aqui template para manter pipeline completo)
// =========================
const Writer = {
  writeWorkout(plan) {
    const lines = [];
    lines.push(plan.summary || "Plano gerado.");
    lines.push("");

    if (Array.isArray(plan.alerts) && plan.alerts.length) {
      lines.push("ALERTAS:");
      for (var i = 0; i < plan.alerts.length; i++) {
        const a = plan.alerts[i] || {};
        lines.push(`- [${String(a.level || "info").toUpperCase()}] ${String(a.message || "")}`);
      }
      lines.push("");
    }

    const perTreino = Array.isArray(plan.perTreino) ? plan.perTreino : [];
    for (var t = 0; t < perTreino.length; t++) {
      const treino = perTreino[t] || {};
      lines.push(String(treino.treinoKey || "Treino"));
      if (treino.notes) lines.push("• " + String(treino.notes));
      lines.push("");

      const exs = Array.isArray(treino.exercises) ? treino.exercises : [];
      for (var e = 0; e < exs.length; e++) {
        const ex = exs[e] || {};
        const m = ex.metrics || {};
        const trend = ex.trendPctVsLast;

        const best = m.bestE1RM != null ? m.bestE1RM : 0;
        const vol = m.volume != null ? m.volume : 0;
        const rpe = m.avgRPE != null ? m.avgRPE : null;

        const next = ex.next || {};
        const action = String(next.action || "maintain");
        const delta = Number(next.deltaKg || 0);
        const repGoal = String(next.repGoal || "8-12");
        const rpeGoal = next.rpeGoal != null ? next.rpeGoal : 8;

        lines.push(
          `- ${String(ex.name || "Exercício")} | best e1RM: ${best} | vol: ${vol} | avg RPE: ${rpe}`
        );
        lines.push(
          `  Próxima: ${action} (${delta >= 0 ? "+" : ""}${round1(delta)}kg), reps ${repGoal}, alvo RPE ${rpeGoal}` +
            (typeof trend === "number" ? ` | tendência vs última: ${trend >= 0 ? "+" : ""}${trend}%` : "")
        );
        if (ex.why) lines.push("  Motivo: " + String(ex.why));
      }
      lines.push("");
    }

    return lines.join("\n").trim();
  },
};

// =========================
// Helpers
// =========================
function jsonOut(obj) {
  return ContentService.createTextOutput(JSON.stringify(obj)).setMimeType(ContentService.MimeType.JSON);
}

function normalizePath(path) {
  const s = String(path || "/").trim();
  if (!s) return "/";
  const cleaned = s.replace(/\/+$/, "");
  return cleaned ? cleaned : "/";
}

function getBodyText(e) {
  try {
    const txt = e && e.postData && typeof e.postData.contents === "string" ? e.postData.contents : "";
    return String(txt || "");
  } catch (err) {
    return "";
  }
}

function safeJsonParse(text) {
  try {
    if (!text) return null;
    return JSON.parse(text);
  } catch (err) {
    return null;
  }
}

function getProp(key, fallback) {
  const v = PropertiesService.getScriptProperties().getProperty(String(key));
  return v != null && String(v).trim() !== "" ? String(v) : fallback;
}

function getRequiredProp(key) {
  const v = PropertiesService.getScriptProperties().getProperty(String(key));
  const s = v != null ? String(v).trim() : "";
  if (!s) throw new Error("Script property obrigatória ausente: " + key);
  return s;
}

function verifyGatewaySecret(req) {
  const expected = getProp("GATEWAY_SECRET", "");
  if (!expected) return true;

  const got = req && req.auth && typeof req.auth.secret === "string" ? String(req.auth.secret) : "";
  return got === expected;
}

function round1(n) {
  const x = Number(n);
  if (!Number.isFinite(x)) return 0;
  return Math.round(x * 10) / 10;
}

function clampIntGAS(v, min, max, fallback) {
  const n = parseInt(String(v), 10);
  if (!Number.isFinite(n)) return fallback;
  return Math.min(max, Math.max(min, n));
}

function clampNumberGAS(v, min, max, fallback) {
  const n = Number(v);
  if (!Number.isFinite(n)) return fallback;
  return Math.min(max, Math.max(min, n));
}