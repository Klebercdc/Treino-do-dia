/**
 * TITAN PRO — Orchestrator (Cloudflare Worker)
 * - Planner: Nemotron via NVIDIA NIM (HTTP)
 * - Verifier: valida/“hardening” do plano
 * - Writer: (1) writer remoto via NIM (meta/llama-3.1-8b-instruct) ou (2) template local
 * - Fallback: heurísticas locais se NIM indisponível/erro
 *
 * Rotas:
 *   GET  /                         health
 *   POST /v1/titanpro/analyze      orchestrator
 *   POST /v1/chat/completions      passthrough (OpenAI-compatible)
 */

const DEFAULTS = Object.freeze({
  SERVICE: "titanpro_orchestrator",
  VERSION: "cfw_v1",
  NIM_ENDPOINT: "https://integrate.api.nvidia.com/v1/chat/completions",
  PLANNER_MODEL: "nvidia/llama-3.1-nemotron-70b-instruct",
  WRITER_MODEL: "meta/llama-3.1-8b-instruct",
  TIMEOUT_MS: 25000,
  MAX_BODY_BYTES: 800_000,
});

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    const path = url.pathname;

    if (request.method === "OPTIONS") return handleOptions(request);

    if (request.method === "GET" && (path === "/" || path === "/v1/health")) {
      return json(
        {
          ok: true,
          service: DEFAULTS.SERVICE,
          version: DEFAULTS.VERSION,
          now: new Date().toISOString(),
        },
        200,
        request
      );
    }

    if (request.method === "POST" && path === "/v1/titanpro/analyze") {
      return handleAnalyze(request, env);
    }

    // Compat/debug: funciona como “gateway OpenAI”
    if (request.method === "POST" && path === "/v1/chat/completions") {
      return handleChatPassthrough(request, env);
    }

    return json(
      { ok: false, error: { code: "NOT_FOUND", message: "Rota não encontrada." } },
      404,
      request
    );
  },
};

// -------------------------
// CORS
// -------------------------
function corsHeaders(request) {
  const origin = request.headers.get("Origin");
  const allowOrigin = origin && origin !== "null" ? origin : "*";

  return {
    "Access-Control-Allow-Origin": allowOrigin,
    "Access-Control-Allow-Methods": "GET,POST,OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type,Authorization",
    "Access-Control-Max-Age": "86400",
    Vary: "Origin",
  };
}

function handleOptions(request) {
  return new Response(null, { status: 204, headers: corsHeaders(request) });
}

function json(obj, status, request) {
  return new Response(JSON.stringify(obj), {
    status,
    headers: {
      "Content-Type": "application/json; charset=utf-8",
      ...corsHeaders(request),
    },
  });
}

function text(str, status, request) {
  return new Response(String(str ?? ""), {
    status,
    headers: {
      "Content-Type": "text/plain; charset=utf-8",
      ...corsHeaders(request),
    },
  });
}

// -------------------------
// Main route: /v1/titanpro/analyze
// -------------------------
async function handleAnalyze(request, env) {
  const requestId = crypto.randomUUID();
  const startedAt = Date.now();

  try {
    const body = await readBodyText(request);
    if (byteLength(body) > DEFAULTS.MAX_BODY_BYTES) {
      return json(
        { ok: false, requestId, error: { code: "BODY_TOO_LARGE", message: "Body muito grande." } },
        413,
        request
      );
    }

    const req = safeJsonParse(body) || {};

    // (Opcional) trava de acesso
    const expectedSecret = (env.GATEWAY_SECRET || "").trim();
    if (expectedSecret) {
      const got = String(req?.auth?.secret || "");
      if (got !== expectedSecret) {
        return json(
          { ok: false, requestId, error: { code: "UNAUTHORIZED", message: "Secret inválido." } },
          401,
          request
        );
      }
    }

    // Aceita wrapper (gateway_request) ou sessão direta
    const session = extractSession(req);
    const history = extractHistory(req);

    if (!session || session.schema !== "titanpro_session_v3") {
      return json(
        {
          ok: false,
          requestId,
          error: { code: "BAD_REQUEST", message: "Esperado session.schema = titanpro_session_v3." },
        },
        400,
        request
      );
    }

    // Chave NVIDIA: preferir secret do Worker; se não existir, usa Authorization Bearer do client (compatibilidade).
    const nvidiaKey = pickNvidiaKey(request, env, req);
    if (!nvidiaKey) {
      return json(
        { ok: false, requestId, error: { code: "NO_NVIDIA_API_KEY", message: "NVIDIA_API_KEY ausente." } },
        401,
        request
      );
    }

    const nimEndpoint = (env.NVIDIA_ENDPOINT || DEFAULTS.NIM_ENDPOINT).trim();
    const plannerModel = (env.PLANNER_MODEL || env.NVIDIA_MODEL || DEFAULTS.PLANNER_MODEL).trim();
    const writerModel = (env.WRITER_MODEL || DEFAULTS.WRITER_MODEL).trim();

    const normalized = normalizeWorkout(session, history);
    const flags = computeFlags(normalized);

    // 1) Planner (Nemotron)
    let plannerEngine = "nemotron";
    let plan = null;

    try {
      plan = await nemotronPlan(
        {
          endpoint: nimEndpoint,
          apiKey: nvidiaKey,
          model: plannerModel,
          context: {
            requestId,
            session: normalized.sessionSlim,
            trends: normalized.trends,
            flags,
          },
        },
        DEFAULTS.TIMEOUT_MS
      );

      // 2) Verifier + hardening
      plan = verifyAndHardenPlan(plan, normalized);
    } catch (err) {
      plannerEngine = "fallback_heuristics";
      plan = fallbackPlan(normalized, flags, String(err?.message || err));
    }

    // 3) Writer (remoto via NIM) — se falhar, template local
    let writerEngine = "nim_writer";
    let writerText = "";

    try {
      writerText = await remoteWriter(
        {
          endpoint: nimEndpoint,
          apiKey: nvidiaKey,
          model: writerModel,
          plan,
          normalized,
          flags,
        },
        DEFAULTS.TIMEOUT_MS
      );
    } catch (err) {
      writerEngine = "template_writer";
      writerText = templateWriter(plan);
    }

    return json(
      {
        ok: true,
        requestId,
        planner: { engine: plannerEngine, model: plannerModel, plan },
        writer: { engine: writerEngine, model: writerModel, text: writerText },
        meta: { service: DEFAULTS.SERVICE, version: DEFAULTS.VERSION, tookMs: Date.now() - startedAt },
      },
      200,
      request
    );
  } catch (err) {
    return json(
      {
        ok: false,
        requestId,
        error: { code: "UNHANDLED", message: String(err?.message || err) },
        meta: { service: DEFAULTS.SERVICE, version: DEFAULTS.VERSION, tookMs: Date.now() - startedAt },
      },
      500,
      request
    );
  }
}

// -------------------------
// Passthrough: /v1/chat/completions (debug/compat)
// -------------------------
async function handleChatPassthrough(request, env) {
  const requestId = crypto.randomUUID();
  try {
    const body = await readBodyText(request);
    if (byteLength(body) > DEFAULTS.MAX_BODY_BYTES) {
      return json(
        { ok: false, requestId, error: { code: "BODY_TOO_LARGE", message: "Body muito grande." } },
        413,
        request
      );
    }

    const payload = safeJsonParse(body);
    if (!payload || typeof payload !== "object") {
      return json(
        { ok: false, requestId, error: { code: "BAD_REQUEST", message: "JSON inválido." } },
        400,
        request
      );
    }

    const nvidiaKey = pickNvidiaKey(request, env, payload);
    if (!nvidiaKey) {
      return json(
        { ok: false, requestId, error: { code: "NO_NVIDIA_API_KEY", message: "NVIDIA_API_KEY ausente." } },
        401,
        request
      );
    }

    const nimEndpoint = (env.NVIDIA_ENDPOINT || DEFAULTS.NIM_ENDPOINT).trim();

    const out = await nimChat(
      {
        endpoint: nimEndpoint,
        apiKey: nvidiaKey,
        payload,
      },
      DEFAULTS.TIMEOUT_MS
    );

    return json(out, 200, request);
  } catch (err) {
    return json(
      { ok: false, requestId, error: { code: "PASSTHROUGH_ERROR", message: String(err?.message || err) } },
      500,
      request
    );
  }
}

// -------------------------
// Request parsing helpers
// -------------------------
function extractSession(req) {
  if (req && req.schema === "titanpro_session_v3") return req;
  if (req && req.session && req.session.schema === "titanpro_session_v3") return req.session;
  return null;
}

function extractHistory(req) {
  const h = req && Array.isArray(req.history) ? req.history : [];
  // permite array de sessões diretas ou wrappers {session:...}
  return h
    .map((x) => {
      if (x && x.schema === "titanpro_session_v3") return x;
      if (x && x.session && x.session.schema === "titanpro_session_v3") return x.session;
      return null;
    })
    .filter(Boolean);
}

function pickNvidiaKey(request, env, req) {
  const envKey = String(env.NVIDIA_API_KEY || "").trim();
  if (envKey) return envKey;

  const auth = request.headers.get("Authorization") || "";
  const m = auth.match(/^Bearer\s+(.+)$/i);
  if (m && m[1]) return String(m[1]).trim();

  const bodyKey = String(req?.auth?.nvidiaApiKey || "").trim();
  if (bodyKey) return bodyKey;

  return "";
}

async function readBodyText(request) {
  // suporta application/json e text/plain
  return await request.text();
}

function safeJsonParse(text) {
  try {
    if (!text) return null;
    return JSON.parse(text);
  } catch {
    return null;
  }
}

function byteLength(str) {
  return new TextEncoder().encode(String(str ?? "")).length;
}

// -------------------------
// Normalization (workout -> sessionSlim + trends)
// -------------------------
function normalizeWorkout(session, historySessions) {
  const sessionSlim = slimSession(session);
  const prev = historySessions && historySessions.length ? slimSession(historySessions[0]) : null;

  const prevBest = prev ? indexBestE1rm(prev) : {};
  const trends = computeTrends(sessionSlim, prevBest);

  return { sessionSlim, trends };
}

function slimSession(session) {
  const out = {
    schema: "titanpro_session_slim_v1",
    capturedAt: session.capturedAt || null,
    objetivo: session.objetivo || null,
    frequenciaSemanal: session.frequenciaSemanal || null,
    sections: [],
  };

  const sections = Array.isArray(session.sections) ? session.sections : [];
  for (const sec of sections) {
    const treinoKey = String(sec?.treinoKey || "Treino");
    const exercises = Array.isArray(sec?.exercises) ? sec.exercises : [];
    const exOut = [];

    for (const ex of exercises) {
      const name = String(ex?.name || "Exercício");
      const sets = Array.isArray(ex?.sets) ? ex.sets : [];
      const valid = [];

      for (const s of sets) {
        const kg = toNum(s?.kg);
        const reps = toNum(s?.reps);
        const rpe = clampInt(toNum(s?.rpe), 1, 10, 10);
        if (!(kg > 0) || !(reps > 0)) continue;

        const e1rm = toNum(s?.e1rm) > 0 ? toNum(s?.e1rm) : brzyckiE1rm(kg, reps);
        valid.push({ kg, reps, rpe, e1rm });
      }

      const metrics = calcMetrics(valid);
      exOut.push({ name, metrics });
    }

    out.sections.push({ treinoKey, exercises: exOut });
  }

  return out;
}

function calcMetrics(validSets) {
  if (!validSets.length) {
    return { bestE1RM: 0, volume: 0, avgRPE: null, avgKg: 0, setCount: 0 };
  }

  let best = 0;
  let vol = 0;
  let sumRpe = 0;
  let sumKg = 0;

  for (const s of validSets) {
    best = Math.max(best, toNum(s.e1rm));
    vol += toNum(s.kg) * toNum(s.reps);
    sumRpe += toNum(s.rpe);
    sumKg += toNum(s.kg);
  }

  const n = validSets.length;
  return {
    bestE1RM: round1(best),
    volume: Math.round(vol),
    avgRPE: round1(sumRpe / n),
    avgKg: round1(sumKg / n),
    setCount: n,
  };
}

function indexBestE1rm(sessionSlim) {
  const map = Object.create(null);
  for (const sec of sessionSlim.sections) {
    for (const ex of sec.exercises) {
      const best = toNum(ex?.metrics?.bestE1RM);
      if (!map[ex.name] || best > map[ex.name]) map[ex.name] = best;
    }
  }
  return map;
}

function computeTrends(sessionSlim, prevBestMap) {
  const trendByExercise = Object.create(null);
  for (const sec of sessionSlim.sections) {
    for (const ex of sec.exercises) {
      const curr = toNum(ex?.metrics?.bestE1RM);
      const prev = toNum(prevBestMap?.[ex.name]);
      if (prev > 0 && curr > 0) {
        trendByExercise[ex.name] = round1(((curr - prev) / prev) * 100);
      } else {
        trendByExercise[ex.name] = null;
      }
    }
  }
  return { trendByExercise };
}

// -------------------------
// Flags (equivalente ao “critical_flags” no seu padrão)
// -------------------------
function computeFlags(normalized) {
  const flags = {
    highRPE: [],
    lowRPE: [],
    e1rmDrop: [],
    notes: [],
  };

  const trend = normalized?.trends?.trendByExercise || {};

  for (const sec of normalized.sessionSlim.sections) {
    for (const ex of sec.exercises) {
      const avgRPE = toNum(ex?.metrics?.avgRPE);
      const delta = trend[ex.name];

      if (avgRPE >= 9) flags.highRPE.push(ex.name);
      if (avgRPE > 0 && avgRPE <= 7.5) flags.lowRPE.push(ex.name);
      if (typeof delta === "number" && delta <= -3) flags.e1rmDrop.push({ name: ex.name, pct: delta });
    }
  }

  if (flags.highRPE.length) flags.notes.push("Há exercícios com RPE médio alto (>=9).");
  if (flags.e1rmDrop.length) flags.notes.push("Há queda relevante de e1RM vs sessão anterior.");

  return flags;
}

// -------------------------
// Planner (Nemotron via NIM) — retorna JSON do plano
// -------------------------
async function nemotronPlan({ endpoint, apiKey, model, context }, timeoutMs) {
  const system = [
    "Você é um PLANNER de treino (não é o redator final).",
    "Saída: JSON válido e somente JSON (sem markdown, sem texto fora do JSON).",
    "",
    "Objetivo: gerar um plano estruturado para a próxima sessão com base em métricas agregadas (best e1RM, volume, avgRPE) e tendência vs sessão anterior.",
    "",
    "Formato obrigatório:",
    "{",
    '  "summary": string,',
    '  "perTreino": [',
    "    {",
    '      "treinoKey": string,',
    '      "notes": string,',
    '      "exercises": [',
    "        {",
    '          "name": string,',
    '          "metrics": { "bestE1RM": number, "volume": number, "avgRPE": number|null, "avgKg": number },',
    '          "trendPctVsLast": number|null,',
    '          "next": { "action": "increase"|"maintain"|"decrease", "deltaKg": number, "repGoal": string, "rpeGoal": number },',
    '          "why": string',
    "        }",
    "      ]",
    "    }",
    "  ],",
    '  "alerts": [ { "level": "info"|"warning"|"critical", "message": string } ]',
    "}",
    "",
    "Regras de ajuste:",
    "- Se avgRPE <= 7.5: increase pequeno (≈ +1–3% ou +2.5kg quando fizer sentido).",
    "- Se avgRPE 8.0–8.5: maintain ou micro-aumento.",
    "- Se avgRPE >= 9.0: maintain/decrease; ajustar repGoal e técnica.",
    "- Se trendPctVsLast <= -3: alerta de fadiga; ajuste conservador.",
  ].join("\n");

  const messages = [
    { role: "system", content: system },
    { role: "user", content: JSON.stringify(context) },
  ];

  const payload = {
    model,
    temperature: 0.2,
    max_tokens: 900,
    messages,
  };

  const resp = await nimChat({ endpoint, apiKey, payload }, timeoutMs);
  const content = String(resp?.choices?.[0]?.message?.content || "");
  const plan = parseJsonFromText(content);
  if (!plan) throw new Error("Planner retornou JSON inválido.");
  return plan;
}

// -------------------------
// Verifier + hardening
// -------------------------
function verifyAndHardenPlan(plan, normalized) {
  if (!plan || typeof plan !== "object") throw new Error("Plano não é objeto.");
  if (typeof plan.summary !== "string") throw new Error("summary ausente.");
  if (!Array.isArray(plan.perTreino)) throw new Error("perTreino não é array.");
  if (!Array.isArray(plan.alerts)) plan.alerts = [];

  const avgKgByName = Object.create(null);
  for (const sec of normalized.sessionSlim.sections) {
    for (const ex of sec.exercises) {
      avgKgByName[ex.name] = toNum(ex?.metrics?.avgKg);
    }
  }

  for (const t of plan.perTreino) {
    if (!t || typeof t.treinoKey !== "string") throw new Error("treinoKey inválido.");
    if (!Array.isArray(t.exercises)) throw new Error("exercises inválido.");
    if (typeof t.notes !== "string") t.notes = "";

    for (const ex of t.exercises) {
      if (!ex || typeof ex.name !== "string") throw new Error("exercise.name inválido.");
      if (!ex.next || typeof ex.next !== "object") throw new Error("next ausente.");

      const action = String(ex.next.action || "maintain");
      ex.next.action = ["increase", "maintain", "decrease"].includes(action) ? action : "maintain";

      const base = toNum(avgKgByName[ex.name]);
      const maxDelta = base > 0 ? Math.max(2.5, round1(base * 0.06)) : 2.5;
      ex.next.deltaKg = round1(clampNum(toNum(ex.next.deltaKg), -maxDelta, maxDelta, 0));

      ex.next.repGoal = typeof ex.next.repGoal === "string" ? ex.next.repGoal : "8-12";
      ex.next.rpeGoal = clampInt(toNum(ex.next.rpeGoal), 6, 10, 8);

      if (!ex.metrics || typeof ex.metrics !== "object") {
        ex.metrics = { bestE1RM: 0, volume: 0, avgRPE: null, avgKg: base };
      } else {
        ex.metrics.avgKg = toNum(ex.metrics.avgKg || base);
      }

      if (typeof ex.trendPctVsLast !== "number" && ex.trendPctVsLast !== null) ex.trendPctVsLast = null;
      if (typeof ex.why !== "string") ex.why = "";
    }
  }

  return plan;
}

// -------------------------
// Fallback heurístico
// -------------------------
function fallbackPlan(normalized, flags, reason) {
  const trend = normalized?.trends?.trendByExercise || {};
  const perTreino = [];

  for (const sec of normalized.sessionSlim.sections) {
    const exercises = [];

    for (const ex of sec.exercises) {
      const m = ex.metrics || {};
      const avgRPE = toNum(m.avgRPE);
      const avgKg = toNum(m.avgKg);
      const deltaTrend = trend[ex.name];

      let action = "maintain";
      let deltaKg = 0;
      let repGoal = "8-12";
      let rpeGoal = 8.5;

      if (avgRPE > 0 && avgRPE <= 7.5) {
        action = "increase";
        deltaKg = avgKg > 0 ? Math.min(2.5, avgKg * 0.03) : 2.5;
        rpeGoal = 8;
      } else if (avgRPE >= 9) {
        action = "decrease";
        deltaKg = avgKg > 0 ? -Math.min(2.5, avgKg * 0.03) : -2.5;
        repGoal = "6-10";
        rpeGoal = 8.5;
      }

      if (typeof deltaTrend === "number" && deltaTrend <= -3) {
        action = "maintain";
        deltaKg = 0;
        repGoal = "6-10";
        rpeGoal = 8;
      }

      exercises.push({
        name: ex.name,
        metrics: {
          bestE1RM: round1(toNum(m.bestE1RM)),
          volume: Math.round(toNum(m.volume)),
          avgRPE: m.avgRPE == null ? null : round1(toNum(m.avgRPE)),
          avgKg: round1(avgKg),
        },
        trendPctVsLast: typeof deltaTrend === "number" ? deltaTrend : null,
        next: { action, deltaKg: round1(deltaKg), repGoal, rpeGoal },
        why: `Fallback local (motivo: ${String(reason || "indisponível")}).`,
      });
    }

    perTreino.push({
      treinoKey: sec.treinoKey,
      notes: "Fallback ativo: ajuste conservador por RPE/tendência.",
      exercises,
    });
  }

  const alerts = [];
  if (flags?.highRPE?.length) alerts.push({ level: "warning", message: `RPE alto em: ${flags.highRPE.join(", ")}` });
  if (flags?.e1rmDrop?.length) alerts.push({ level: "warning", message: "Queda de e1RM vs sessão anterior em alguns exercícios." });
  alerts.push({ level: "info", message: "Fallback heurístico usado (planner indisponível/erro/JSON inválido)." });

  return {
    summary: "Plano (fallback): ajustes conservadores por RPE médio e tendência de e1RM.",
    perTreino,
    alerts,
  };
}

// -------------------------
// Writer remoto (NIM) e writer local (template)
// -------------------------
async function remoteWriter({ endpoint, apiKey, model, plan, normalized, flags }, timeoutMs) {
  const system = [
    "Você é um redator de relatório de treino.",
    "Entrada: plano estruturado (JSON) + contexto resumido.",
    "Saída: texto em pt-BR, objetivo e prático.",
    "Estrutura: (1) resumo geral; (2) por treino; (3) recomendações de próxima sessão; (4) alertas/fadiga se existirem.",
    "Não invente exercícios que não estejam no plano.",
  ].join("\n");

  const user = JSON.stringify({
    plan,
    flags,
    session: normalized.sessionSlim,
    trends: normalized.trends,
  });

  const payload = {
    model,
    temperature: 0.2,
    max_tokens: 700,
    messages: [
      { role: "system", content: system },
      { role: "user", content: user },
    ],
  };

  const resp = await nimChat({ endpoint, apiKey, payload }, timeoutMs);
  const content = String(resp?.choices?.[0]?.message?.content || "");
  if (!content.trim()) throw new Error("Writer remoto retornou vazio.");
  return content.trim();
}

function templateWriter(plan) {
  const lines = [];
  lines.push(plan.summary || "Plano gerado.");
  lines.push("");

  if (Array.isArray(plan.alerts) && plan.alerts.length) {
    lines.push("ALERTAS:");
    for (const a of plan.alerts) {
      lines.push(`- [${String(a.level || "info").toUpperCase()}] ${String(a.message || "")}`);
    }
    lines.push("");
  }

  const perTreino = Array.isArray(plan.perTreino) ? plan.perTreino : [];
  for (const t of perTreino) {
    lines.push(String(t.treinoKey || "Treino"));
    if (t.notes) lines.push("• " + String(t.notes));
    lines.push("");

    const exs = Array.isArray(t.exercises) ? t.exercises : [];
    for (const ex of exs) {
      const m = ex.metrics || {};
      const next = ex.next || {};
      const trend = ex.trendPctVsLast;

      lines.push(
        `- ${String(ex.name)} | best e1RM: ${toNum(m.bestE1RM)} | vol: ${toNum(m.volume)} | avg RPE: ${m.avgRPE == null ? "-" : toNum(m.avgRPE)}`
      );
      lines.push(
        `  Próxima: ${String(next.action || "maintain")} (${toNum(next.deltaKg) >= 0 ? "+" : ""}${round1(toNum(next.deltaKg))}kg), reps ${String(next.repGoal || "8-12")}, alvo RPE ${toNum(next.rpeGoal) || 8}` +
          (typeof trend === "number" ? ` | tendência: ${trend >= 0 ? "+" : ""}${trend}%` : "")
      );
      if (ex.why) lines.push("  Motivo: " + String(ex.why));
    }
    lines.push("");
  }

  return lines.join("\n").trim();
}

// -------------------------
// NIM client (HTTP)
// -------------------------
async function nimChat({ endpoint, apiKey, payload }, timeoutMs) {
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), timeoutMs);

  try {
    const res = await fetch(endpoint, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${apiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify(payload),
      signal: controller.signal,
    });

    const raw = await res.text();
    let data = null;
    try {
      data = JSON.parse(raw);
    } catch {
      data = null;
    }

    if (!res.ok) {
      const msg = data?.error?.message || data?.detail || raw || `HTTP ${res.status}`;
      throw new Error(`NIM ${res.status}: ${msg}`);
    }

    if (!data) throw new Error("Resposta NIM não-JSON.");
    return data;
  } finally {
    clearTimeout(timer);
  }
}

function parseJsonFromText(text) {
  if (!text) return null;

  // JSON direto
  const direct = safeJsonParse(text);
  if (direct) return direct;

  // Extrai do primeiro { ao último }
  const first = text.indexOf("{");
  const last = text.lastIndexOf("}");
  if (first >= 0 && last > first) {
    return safeJsonParse(text.slice(first, last + 1));
  }
  return null;
}

// -------------------------
// Math helpers
// -------------------------
function toNum(v) {
  const n = Number(v);
  return Number.isFinite(n) ? n : 0;
}

function round1(n) {
  const x = Number(n);
  if (!Number.isFinite(x)) return 0;
  return Math.round(x * 10) / 10;
}

function clampInt(n, min, max, fallback) {
  const x = Number.parseInt(String(n), 10);
  if (!Number.isFinite(x)) return fallback;
  return Math.min(max, Math.max(min, x));
}

function clampNum(n, min, max, fallback) {
  const x = Number(n);
  if (!Number.isFinite(x)) return fallback;
  return Math.min(max, Math.max(min, x));
}

// Brzycki e1RM (aprox) — usado só se set.e1rm não vier do client
function brzyckiE1rm(kg, reps) {
  const r = toNum(reps);
  const w = toNum(kg);
  if (!(w > 0) || !(r > 0)) return 0;
  const denom = 1.0278 - 0.0278 * r;
  if (!(denom > 0)) return 0;
  return w / denom;
}